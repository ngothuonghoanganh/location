import { createContext, isValidElement, cloneElement, useContext, useEffect, createElement, Fragment, useState, useRef } from 'react';
import { Line, Rectangle, Path, Circle, RoughProvider } from 'react-roughjs';
export { Circle, Rectangle } from 'react-roughjs';
import { scaleBand, scaleLinear } from 'd3-scale';
import { arc, pie, line, curveCardinal, area } from 'd3-shape';
import { createPortal } from 'react-dom';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var ChartContext = createContext(null);

var isNil = function isNil(x) {
  return x == null;
};
var isFunction = function isFunction(x) {
  return typeof x === 'function';
};
var removeDuplicates = function removeDuplicates(xs) {
  var res = {};
  xs.forEach(function (key) {
    res[key] = true;
  });
  return Object.keys(res);
};
var getBandWidth = function getBandWidth(scale) {
  var ticks = 'ticks' in scale ? scale.ticks() : scale.domain();

  if (ticks.length <= 1) {
    var _scale$range = scale.range(),
        low = _scale$range[0],
        high = _scale$range[1];

    return Math.abs(high - low);
  }

  return Math.abs(scale(ticks[1]) - scale(ticks[0]));
};
var processTooltipHandlers = function processTooltipHandlers(child, handlers) {
  if (!isValidElement(child)) {
    return null;
  }

  var additionalProps = Object.entries(handlers).reduce(function (acc, _ref) {
    var handlerName = _ref[0],
        f = _ref[1];

    if (child.props[handlerName]) {
      acc[handlerName] = function (e) {
        f(e);
        child.props[handlerName](e);
      };
    } else {
      acc[handlerName] = f;
    }

    return acc;
  }, {});
  return cloneElement(child, additionalProps);
};

var getDomain = function getDomain(type, values) {
  var min = Math.min.apply(Math, values);
  return type === 'scaleBand' ? values : [min > 0 ? 0 : min, Math.max.apply(Math, values)];
};

function useChartContext(props, scaleKeyName) {
  var value = useContext(ChartContext);

  if (value === null) {
    throw Error('Chart Components must be wrapped inside <ChartProvider>!');
  }

  var data = value.data,
      contentWidth = value.contentWidth,
      contentHeight = value.contentHeight,
      setScaleData = value.setScaleData,
      scaleData = value.scaleData;
  var userXScale = scaleData.userXScale,
      userYScale = scaleData.userYScale,
      internalXScale = scaleData.internalXScale,
      internalYScale = scaleData.internalYScale;
  var dataKey = props.dataKey;
  useEffect(function () {
    if (!scaleKeyName) {
      return;
    }

    if (scaleKeyName === 'xDataKey') {
      if (userXScale) {
        userXScale.range([0, contentWidth]);
        setScaleData(function (prev) {
          return _extends({}, prev, {
            xScale: userXScale,
            xDataKey: dataKey
          });
        });
        return;
      }

      var values = data.map(function (d) {
        return d[dataKey];
      });
      internalXScale.range([0, contentWidth]);
      var domain = getDomain('scaleBand', values);
      internalXScale.domain(domain);
      setScaleData(function (prev) {
        var _extends2;

        return _extends({}, prev, (_extends2 = {}, _extends2[scaleKeyName] = dataKey, _extends2.xScale = internalXScale, _extends2));
      });
    }

    if (scaleKeyName === 'yDataKey' && dataKey) {
      if (userYScale) {
        userYScale.range([0, contentHeight]);
        setScaleData(function (prev) {
          return _extends({}, prev, {
            yScale: userYScale,
            yDataKey: dataKey
          });
        });
      } else {
        var _values = data.map(function (d) {
          return d[dataKey];
        });

        internalYScale.range([0, contentHeight]);

        var _domain = getDomain('scaleLinear', _values);

        internalYScale.domain(_domain);
        setScaleData(function (prev) {
          var _extends3;

          return _extends({}, prev, (_extends3 = {}, _extends3[scaleKeyName] = dataKey, _extends3.yScale = internalYScale, _extends3));
        });
      }
    }

    var getSeriesScaleData = function getSeriesScaleData(prev) {
      var _extends4;

      var yDataKey = prev.yDataKey;
      var prevDataKeys = prev[scaleKeyName];
      var newDataKeys = prevDataKeys.indexOf(dataKey) > -1 ? prevDataKeys : [].concat(prevDataKeys, [dataKey]);

      var newScaleData = _extends({}, prev, (_extends4 = {}, _extends4[scaleKeyName] = newDataKeys, _extends4));

      var barDataKeys = newScaleData.barDataKeys,
          lineDataKeys = newScaleData.lineDataKeys,
          circleDataKeys = newScaleData.circleDataKeys,
          areaDataKeys = newScaleData.areaDataKeys;

      if (userYScale) {
        userYScale.range([contentHeight, 0]);
        newScaleData.yScale = userYScale;
      } else {
        var noneStackedValues = removeDuplicates([].concat(lineDataKeys, barDataKeys, circleDataKeys)).reduce(function (acc, groupName) {
          acc.push.apply(acc, data.map(function (item) {
            return +item[groupName];
          }));
          return acc;
        }, []);
        var areaValues = data.map(function (d) {
          return areaDataKeys.reduce(function (sum, key) {
            return sum + d[key];
          }, 0);
        });

        var _values2 = yDataKey ? data.map(function (d) {
          return d[yDataKey];
        }) : [].concat(noneStackedValues, areaValues);

        var _domain2 = getDomain('scaleLinear', _values2);

        internalYScale.domain(_domain2);
        internalYScale.range([contentHeight, 0]);
        newScaleData.yScale = internalYScale;
      }

      return newScaleData;
    };

    if (scaleKeyName === 'barDataKeys') {
      setScaleData(function (prev) {
        var newScaleData = getSeriesScaleData(prev);
        var barScale = scaleBand().domain(newScaleData[scaleKeyName]);
        newScaleData.barScale = barScale;
        return newScaleData;
      });
    }

    if (scaleKeyName === 'lineDataKeys' || scaleKeyName === 'circleDataKeys' || scaleKeyName === 'areaDataKeys') {
      setScaleData(function (prev) {
        return getSeriesScaleData(prev);
      });
    }
  }, [scaleKeyName, dataKey, contentHeight, contentWidth, data]);

  var margin = _extends({}, value.margin);

  var width = value.width;
  var height = value.height;
  return _extends({}, value, {
    width: width,
    height: height,
    contentWidth: width - margin.left - margin.right,
    contentHeight: height - margin.top - margin.bottom,
    options: _extends({}, value.options, {}, props.options || {}),
    margin: margin,
    data: !isNil(props.data) ? props.data : value.data,
    scaleData: value.scaleData,
    setScaleData: value.setScaleData
  });
}

var XAxis = function XAxis(props) {
  if (!props.dataKey) {
    throw Error('dataKey of XAxisProps is required');
  }

  var _useChartContext = useChartContext(props, 'xDataKey'),
      options = _useChartContext.options,
      contentHeight = _useChartContext.contentHeight,
      contentWidth = _useChartContext.contentWidth,
      scaleData = _useChartContext.scaleData;

  var xScale = scaleData.xScale;
  var tickSize = props.tickSize,
      fontSize = props.fontSize,
      format = props.format,
      tickCount = props.tickCount;

  if (!xScale) {
    return null;
  }

  var ticks = 'ticks' in xScale ? xScale.ticks(tickCount) : xScale.domain();
  var bandwidth = getBandWidth(xScale);
  var y = contentHeight;
  return createElement(Fragment, null, createElement(Line, {
    x1: 0,
    y1: y,
    x2: contentWidth + bandwidth / 2,
    y2: y,
    options: _extends({
      bowing: 0.2
    }, options)
  }), ticks.map(function (t, index) {
    return createElement(Fragment, {
      key: index
    }, createElement(Line, {
      x1: xScale(t) + bandwidth / 2,
      y1: y,
      x2: xScale(t) + bandwidth / 2,
      y2: y + tickSize,
      options: _extends({
        strokeWidth: 2
      }, options)
    }), createElement("text", {
      x: xScale(t) + bandwidth / 2,
      y: y + tickSize + fontSize,
      stroke: options.stroke,
      fill: options.stroke,
      textAnchor: "middle"
    }, isFunction(format) ? format(t) : String(t)));
  }));
};
XAxis.displayName = 'XAxis';
XAxis.defaultProps = {
  tickSize: 10,
  fontSize: 16,
  tickCount: 10
};

var YAxis = function YAxis(props) {
  var tickSize = props.tickSize,
      fontSize = props.fontSize,
      format = props.format,
      tickCount = props.tickCount;

  var _useChartContext = useChartContext(props, 'yDataKey'),
      options = _useChartContext.options,
      contentHeight = _useChartContext.contentHeight,
      scaleData = _useChartContext.scaleData;

  var scale = scaleData.yScale;

  if (!scale) {
    return null;
  }

  var ticks = scale.ticks ? scale.ticks(tickCount) : scale.domain();
  return createElement(Fragment, null, createElement(Line, {
    x1: 0,
    y1: 0,
    x2: 0,
    y2: contentHeight,
    options: _extends({
      bowing: 0.2
    }, options)
  }), ticks.map(function (t, index) {
    return createElement(Fragment, {
      key: index
    }, createElement(Line, {
      x1: 0 - tickSize,
      x2: 0,
      y1: scale(t),
      y2: scale(t),
      options: _extends({
        strokeWidth: 2
      }, options)
    }), createElement("text", {
      x: 0 - tickSize,
      y: scale(t) + fontSize / 3,
      stroke: options.stroke,
      fill: options.stroke,
      textAnchor: "end"
    }, isFunction(format) ? format(t) : String(t)));
  }));
};
YAxis.displayName = 'YAxis';
YAxis.defaultProps = {
  tickSize: 10,
  fontSize: 16,
  tickCount: 10
};

var mousePositions = function mousePositions(event) {
  var IE = !!document.all;
  var x;
  var y;

  if (IE) {
    x = event.clientX + document.body.scrollLeft;
    y = event.clientY + document.body.scrollTop;
  } else {
    x = window.Event ? event.pageX : event.clientX + (document.documentElement.scrollLeft ? document.documentElement.scrollLeft : document.body.scrollLeft);
    y = window.Event ? event.pageY : event.clientY + (document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop);
  }

  return {
    x: x,
    y: y
  };
};

var useTooltipGenerator = function useTooltipGenerator(props) {
  var dataKey = props.dataKey;

  if (!dataKey) {
    throw Error('dataKey is Required!');
  }

  var _useChartContext = useChartContext(props),
      setTooltipData = _useChartContext.setTooltipData;

  var generateHandlers = function generateHandlers(item, content) {
    if (content === void 0) {
      content = {
        name: '',
        value: ''
      };
    }

    return {
      onMouseOver: function onMouseOver(e) {
        var _mousePositions = mousePositions(e),
            x = _mousePositions.x,
            y = _mousePositions.y;

        setTooltipData(function (prev) {
          return _extends({}, prev, {
            showToolTip: true,
            x: x,
            y: y,
            name: content.name,
            value: content.value,
            activeItem: item
          });
        });
      },
      onMouseMove: function onMouseMove(e) {
        var _mousePositions2 = mousePositions(e),
            x = _mousePositions2.x,
            y = _mousePositions2.y;

        setTooltipData(function (prev) {
          return _extends({}, prev, {
            showToolTip: true,
            x: x,
            y: y,
            activeItem: item
          });
        });
      },
      onMouseOut: function onMouseOut() {
        setTooltipData(function (prev) {
          return _extends({}, prev, {
            showToolTip: false
          });
        });
      }
    };
  };

  return {
    generateHandlers: generateHandlers
  };
};

var BarSeries = function BarSeries(props) {
  var dataKey = props.dataKey,
      options = props.options;

  var _useChartContext = useChartContext(props, 'barDataKeys'),
      data = _useChartContext.data,
      contentHeight = _useChartContext.contentHeight,
      scaleData = _useChartContext.scaleData;

  var xScale = scaleData.xScale,
      barScale = scaleData.barScale,
      yScale = scaleData.yScale,
      xDataKey = scaleData.xDataKey;

  var _useTooltipGenerator = useTooltipGenerator(props),
      generateHandlers = _useTooltipGenerator.generateHandlers;

  if (!dataKey) {
    throw Error('dataKey is Required!');
  }

  if (!xScale || !barScale || !yScale || !xDataKey) {
    return null;
  }

  var width = getBandWidth(xScale);
  var offset = width * 0.2 / 2;

  var generateChildProps = function generateChildProps(item) {
    var x = xScale(item[xDataKey]);
    barScale.range([x + offset, x + width - offset]);
    var min = yScale.domain()[0];
    var y0 = yScale(0);
    var itemY = yScale(item[dataKey]);
    var y = min >= 0 ? itemY : yScale(Math.max(item[dataKey], 0));
    var height = min >= 0 ? contentHeight - itemY : Math.abs(y0 - itemY);
    return {
      x: barScale(dataKey),
      y: y,
      width: barScale.bandwidth(),
      height: height,
      options: _extends({
        fill: 'black'
      }, options)
    };
  };

  var children = props.children;
  return createElement(Fragment, null, data.map(function (item, index) {
    var handlers = generateHandlers(item, {
      name: "" + dataKey,
      value: "" + item[dataKey]
    });
    var childProps = generateChildProps(item);
    return isFunction(children) ? processTooltipHandlers(children(item, childProps, index), handlers) : createElement(Rectangle, Object.assign({
      key: index
    }, childProps, handlers));
  }));
};
BarSeries.displayName = 'BarSeries';

var Arc = function Arc(props) {
  var innerRadius = props.innerRadius,
      outerRadius = props.outerRadius,
      startAngle = props.startAngle,
      endAngle = props.endAngle,
      padAngle = props.padAngle,
      options = props.options,
      cx = props.cx,
      cy = props.cy,
      rest = _objectWithoutPropertiesLoose(props, ["innerRadius", "outerRadius", "startAngle", "endAngle", "padAngle", "options", "cx", "cy"]);

  var a = arc();
  var d = a({
    innerRadius: innerRadius,
    outerRadius: outerRadius,
    startAngle: startAngle,
    endAngle: endAngle,
    padAngle: padAngle
  });
  return createElement(Path, Object.assign({
    d: d,
    transform: "translate(" + cx + ", " + cy + ")",
    options: options
  }, rest));
};
Arc.displayName = 'RcArc';
Arc.defaultProps = {
  innerRadius: 0,
  outerRadius: 0,
  startAngle: 0
};

var ArcSeries = function ArcSeries(props) {
  var _useChartContext = useChartContext(props),
      data = _useChartContext.data,
      options = _useChartContext.options,
      contentHeight = _useChartContext.contentHeight,
      contentWidth = _useChartContext.contentWidth;

  var _useTooltipGenerator = useTooltipGenerator(props),
      generateHandlers = _useTooltipGenerator.generateHandlers;

  var dataKey = props.dataKey,
      cx = props.cx,
      cy = props.cy,
      innerRadiusPercent = props.innerRadiusPercent,
      outerRadiusPercent = props.outerRadiusPercent,
      padAngleProp = props.padAngle,
      startAngleProp = props.startAngle,
      endAngleProp = props.endAngle,
      children = props.children;
  var newCx = !isNil(cx) ? cx : contentWidth / 2;
  var newCy = !isNil(cy) ? cy : contentHeight / 2;
  var radius = Math.min(newCx, newCy);
  var arcs = pie().startAngle(startAngleProp).padAngle(padAngleProp).endAngle(endAngleProp)(data.map(function (d) {
    return d[dataKey];
  }));
  var arcsData = arcs.map(function (arc) {
    var startAngle = arc.startAngle,
        endAngle = arc.endAngle,
        padAngle = arc.padAngle;
    return {
      innerRadius: radius * innerRadiusPercent,
      outerRadius: radius * outerRadiusPercent,
      startAngle: startAngle,
      endAngle: endAngle,
      padAngle: padAngle
    };
  });
  var total = data.reduce(function (acc, d) {
    return acc + d[dataKey];
  }, 0);
  return createElement(Fragment, null, arcsData.map(function (arcProps, index) {
    var item = data[index];
    var percent = (item[dataKey] / total * 100).toPrecision(3);
    var handlers = generateHandlers(item, {
      name: dataKey + " " + item[dataKey],
      value: percent + "%"
    });

    var childProps = _extends({}, arcProps, {
      cx: newCx,
      cy: newCy,
      options: _extends({
        fill: 'black'
      }, options)
    });

    if (isFunction(children)) {
      return processTooltipHandlers(children(item, childProps, index), handlers);
    }

    return createElement(Arc, Object.assign({
      key: index
    }, childProps, handlers));
  }));
};
ArcSeries.displayName = 'ArcSeries';
ArcSeries.defaultProps = {
  innerRadiusPercent: 0,
  outerRadiusPercent: 1,
  padAngle: 0,
  startAngle: 0,
  endAngle: Math.PI * 2
};

var Y0 = function Y0(props) {
  var _useChartContext = useChartContext(props),
      yScale = _useChartContext.scaleData.yScale,
      contentWidth = _useChartContext.contentWidth;

  if (!yScale) {
    return null;
  }

  return createElement(Line, {
    y1: yScale(0),
    y2: yScale(0),
    x1: 0,
    x2: contentWidth,
    strokeDasharray: "30",
    options: _extends({
      bowing: 0.2
    }, props.options)
  });
};
Y0.displayName = 'Y0';

var CircleSeries = function CircleSeries(props) {
  var _useChartContext = useChartContext(props, 'circleDataKeys'),
      scaleData = _useChartContext.scaleData,
      data = _useChartContext.data,
      options = _useChartContext.options;

  var xScale = scaleData.xScale,
      yScale = scaleData.yScale,
      xDataKey = scaleData.xDataKey;
  var dataKey = props.dataKey;

  var _useTooltipGenerator = useTooltipGenerator(props),
      generateHandlers = _useTooltipGenerator.generateHandlers;

  if (!xScale || !yScale || !dataKey || !xDataKey) {
    return null;
  }

  var bandwidth = getBandWidth(xScale);
  var points = data.map(function (item) {
    return [xScale(item[xDataKey]), yScale(item[dataKey])];
  });
  var children = props.children;
  return createElement(Fragment, null, points.map(function (_ref, index) {
    var x = _ref[0],
        y = _ref[1];
    var childProps = {
      x: x + bandwidth / 2,
      y: y,
      diameter: 10,
      options: _extends({}, options)
    };
    var item = data[index];
    var handlers = generateHandlers(data[index], {
      name: item[xDataKey] + " " + dataKey,
      value: "" + item[dataKey]
    });

    if (isFunction(children)) {
      return processTooltipHandlers(children(data[index], childProps, index), handlers);
    }

    return createElement(Circle, Object.assign({
      key: index
    }, childProps, handlers));
  }));
};
CircleSeries.displayName = 'CircleSeries';

var LineSeries = function LineSeries(props) {
  var _useChartContext = useChartContext(props, 'lineDataKeys'),
      scaleData = _useChartContext.scaleData,
      data = _useChartContext.data,
      options = _useChartContext.options;

  var xScale = scaleData.xScale,
      yScale = scaleData.yScale,
      xDataKey = scaleData.xDataKey;
  var dataKey = props.dataKey,
      curve = props.curve;

  if (!xScale || !yScale || !dataKey || !xDataKey) {
    return null;
  }

  var bandwidth = getBandWidth(xScale);
  var points = data.map(function (item) {
    return [xScale(item[xDataKey]), yScale(item[dataKey])];
  });
  var line$1 = line().curve(curve);
  var path = line$1(points);
  return createElement(Fragment, null, createElement(Path, {
    transform: "translate(" + bandwidth / 2 + ", 0)",
    d: path,
    options: options
  }), createElement(CircleSeries, Object.assign({}, props)));
};
LineSeries.displayName = 'LineSeries';
LineSeries.defaultProps = {
  curve: curveCardinal.tension(0.5)
};

var Tooltip = function Tooltip(props) {
  var _useChartContext = useChartContext(props),
      tooltipData = _useChartContext.tooltipData,
      setTooltipData = _useChartContext.setTooltipData,
      contentWidth = _useChartContext.contentWidth,
      options = _useChartContext.options;

  var x = tooltipData.x,
      y = tooltipData.y,
      showToolTip = tooltipData.showToolTip,
      name = tooltipData.name,
      value = tooltipData.value,
      activeItem = tooltipData.activeItem;
  var propsWidth = props.width,
      height = props.height,
      fontSize = props.fontSize,
      children = props.children;

  var _React$useState = useState(120),
      internalWidth = _React$useState[0],
      setWidth = _React$useState[1];

  var textRef = useRef();
  var width = isNil(propsWidth) ? internalWidth : propsWidth;
  useEffect(function () {
    var node = textRef.current;

    if (node) {
      var _node$getBBox = node.getBBox(),
          textWidth = _node$getBBox.width;

      setWidth(textWidth + 30);
    }
  }, [textRef.current]);

  if (!showToolTip || !activeItem) {
    return null;
  }

  var left = contentWidth - x < width + 20 ? x - 20 - width : x + 20;

  var ellipse = function ellipse(s, length) {
    if (s === void 0) {
      s = '';
    }

    return s.length > length ? s.slice(0, length) + "..." : s;
  };

  var renderChildren = function renderChildren() {
    var text = function text(s) {
      return createElement("text", {
        ref: textRef,
        textAnchor: "middle",
        stroke: "black",
        fill: "black",
        x: width / 2,
        y: height / 2 + fontSize / 3
      }, s);
    };

    if (isFunction(children)) {
      var _content = children(activeItem);

      return typeof _content === 'string' ? text(_content) : _content;
    }

    return text(ellipse(name, 20) + ": " + ellipse(value, 5));
  };

  var content = createElement("div", {
    style: {
      position: 'absolute',
      left: left,
      top: y - height / 2
    }
  }, createElement("svg", {
    width: width + 4,
    height: height + 4
  }, createElement("g", {
    transform: "translate(2, 2)"
  }, createElement(RoughProvider, null, createElement(Rectangle, {
    width: width,
    height: height,
    onMouseOver: function onMouseOver(e) {
      setTooltipData(function (prev) {
        return _extends({}, prev, {
          x: e.clientX,
          y: e.clientY
        });
      });
    },
    onMouseMove: function onMouseMove(e) {
      setTooltipData(function (prev) {
        return _extends({}, prev, {
          x: e.clientX,
          y: e.clientY
        });
      });
    },
    onMouseOut: function onMouseOut() {
      setTooltipData(function (prev) {
        return _extends({}, prev, {
          showToolTip: false
        });
      });
    },
    options: _extends({
      fill: 'white',
      fillStyle: 'solid',
      strokeWidth: 2
    }, options)
  })), createElement(RoughProvider, null, renderChildren()))));
  return createPortal(content, document.body);
};
Tooltip.displayName = 'Tooltip';
Tooltip.defaultProps = {
  height: 40,
  fontSize: 16
};

var Provider = ChartContext.Provider;
var defaultMargin = {
  top: 10,
  right: 10,
  bottom: 50,
  left: 50
};
var ChartProvider = function ChartProvider(props) {
  var _React$useState = useState(0),
      innerHeight = _React$useState[0],
      setInnerHeight = _React$useState[1];

  var _React$useState2 = useState(0),
      innerWidth = _React$useState2[0],
      setInnerWidth = _React$useState2[1];

  var ref = useRef();
  var internalXScale = scaleBand();
  var internalYScale = scaleLinear();

  var _React$useState3 = useState({
    barDataKeys: [],
    lineDataKeys: [],
    circleDataKeys: [],
    areaDataKeys: [],
    xScale: props.xScale || internalXScale,
    yScale: props.yScale || internalYScale,
    userXScale: props.xScale,
    userYScale: props.yScale,
    internalXScale: internalXScale,
    internalYScale: internalYScale
  }),
      scaleData = _React$useState3[0],
      _setScaleData = _React$useState3[1];

  var _React$useState4 = useState({
    x: -1,
    y: -1,
    showToolTip: false,
    name: '',
    value: '',
    activeItem: null
  }),
      tooltipData = _React$useState4[0],
      _setTooltipData = _React$useState4[1];

  useEffect(function () {
    var handleResize = function handleResize() {
      if (ref.current && (isNil(props.height) || isNil(props.width))) {
        var boundingRect = ref.current.parentElement.getBoundingClientRect();
        setInnerHeight(boundingRect.height);
        setInnerWidth(boundingRect.width);
      }
    };

    handleResize();
    window.addEventListener('resize', handleResize);
    return function () {
      return window.removeEventListener('resize', handleResize);
    };
  }, [props.height, props.width, ref.current]);
  var height = !isNil(props.height) ? props.height : innerHeight;
  var width = !isNil(props.width) ? props.width : innerWidth;
  var propsMargin = props.margin;

  var margin = _extends({}, defaultMargin, {}, propsMargin);

  var shouldRenderChildren = function shouldRenderChildren() {
    return height && width;
  };

  return createElement(Provider, {
    value: _extends({}, props, {
      height: height,
      width: width,
      margin: margin,
      scaleData: scaleData,
      setScaleData: function setScaleData(f) {
        return _setScaleData(f);
      },
      contentHeight: height - margin.bottom - margin.top,
      contentWidth: width - margin.left - margin.right,
      tooltipData: tooltipData,
      setTooltipData: function setTooltipData(f) {
        return _setTooltipData(f);
      }
    })
  }, createElement("svg", {
    height: height,
    width: width,
    ref: ref,
    viewBox: props.viewBox
  }, createElement(RoughProvider, {
    transform: "translate(" + margin.left + ", " + margin.top + ")",
    config: {
      options: props.options
    }
  }, shouldRenderChildren() && props.children)));
};
ChartProvider.displayName = 'ChartProvider';
ChartProvider.defaultProps = {
  data: [],
  options: {},
  margin: defaultMargin
};

var AreaSeries = function AreaSeries(props) {
  var _useChartContext = useChartContext(props, 'areaDataKeys'),
      scaleData = _useChartContext.scaleData,
      data = _useChartContext.data,
      options = _useChartContext.options;

  var xScale = scaleData.xScale,
      yScale = scaleData.yScale,
      xDataKey = scaleData.xDataKey,
      areaDataKeys = scaleData.areaDataKeys;
  var dataKey = props.dataKey,
      curve = props.curve,
      children = props.children,
      padding = props.padding;

  var _useTooltipGenerator = useTooltipGenerator(props),
      generateHandlers = _useTooltipGenerator.generateHandlers;

  if (!xScale || !yScale || !dataKey || !xDataKey) {
    return null;
  }

  var areaKeyIndex = areaDataKeys.indexOf(dataKey);

  var calculateY = function calculateY(d) {
    if (areaKeyIndex === 0) {
      return {
        y0: yScale(yScale.domain()[0]),
        y1: yScale(d[dataKey])
      };
    }

    var sum = function sum(keys) {
      if (keys === void 0) {
        keys = [];
      }

      return keys.reduce(function (acc, key) {
        return acc + d[key];
      }, 0);
    };

    return {
      y0: yScale(sum(areaDataKeys.slice(0, areaKeyIndex))) - padding,
      y1: yScale(sum(areaDataKeys.slice(0, areaKeyIndex + 1)))
    };
  };

  var bandwidth = getBandWidth(xScale);
  var positions = data.map(function (item) {
    var _calculateY = calculateY(item),
        y0 = _calculateY.y0,
        y1 = _calculateY.y1;

    return {
      x: xScale(item[xDataKey]),
      y0: y0,
      y1: y1
    };
  });
  var area$1 = area().x(function (d) {
    return d.x;
  }).y1(function (d) {
    return d.y1;
  }).y0(function (d) {
    return d.y0;
  }).curve(curve);
  var areaPath = area$1(positions);
  return createElement(Fragment, null, createElement(Path, {
    transform: "translate(" + bandwidth / 2 + ", 0)",
    d: areaPath,
    options: _extends({
      fill: options.stroke
    }, options)
  }), positions.map(function (_ref, index) {
    var x = _ref.x,
        y1 = _ref.y1;
    var childProps = {
      x: x + bandwidth / 2,
      y: y1,
      diameter: 12,
      options: {
        fill: options.fill || options.stroke,
        strokeWidth: 2,
        fillStyle: 'solid',
        stroke: 'white'
      }
    };
    var item = data[index];
    var handlers = generateHandlers(data[index], {
      name: item[xDataKey] + " " + dataKey,
      value: "" + item[dataKey]
    });

    if (isFunction(children)) {
      return processTooltipHandlers(children(data[index], childProps, index), handlers);
    }

    return createElement(Circle, Object.assign({
      key: index
    }, childProps, handlers));
  }));
};
AreaSeries.displayName = 'LineSeries';
AreaSeries.defaultProps = {
  curve: curveCardinal.tension(0.5),
  padding: 6
};

export { Arc, ArcSeries, AreaSeries, BarSeries, ChartProvider, CircleSeries, LineSeries, Tooltip, XAxis, Y0, YAxis };
//# sourceMappingURL=index.modern.js.map
