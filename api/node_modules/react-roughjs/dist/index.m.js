import { useRef, useEffect, createContext, useContext, useState, createElement } from 'react';
import { arc } from 'd3-shape';
import shallowEqual from 'shallowequal';
import roughjs from 'roughjs/dist/rough.umd';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var isEqual = function isEqual(depsA, depsB) {
  if (depsA === void 0) {
    depsA = [];
  }

  if (depsB === void 0) {
    depsB = [];
  }

  if (depsA.length !== depsB.length) {
    return false;
  }

  return depsA.every(function (a, index) {
    return shallowEqual(a, depsB[index]);
  });
};

var useShallowEqual = function useShallowEqual(f, deps) {
  var ref = useRef([]);

  if (!isEqual(ref.current, deps)) {
    ref.current = deps;
  }

  useEffect(f, ref.current);
};

var Context = createContext(null);

var loopHandlers = function loopHandlers(node, fName, handlers) {
  Object.keys(handlers).forEach(function (name) {
    var eventName = name.replace('on', '').toLowerCase();
    node[fName](eventName, handlers[name]);
  });
};

var createSvgNode = function createSvgNode(tagName, attributes) {
  var common = {
    opacity: '0',
    fill: 'black',
    stroke: 'black'
  };

  var attrs = _extends({}, common, {}, attributes);

  var nsString = 'http://www.w3.org/2000/svg';
  var newTagName = tagName;

  if (tagName === 'arc') {
    newTagName = 'path';
    var arc$1 = arc();

    var _attrs = attrs,
        innerRadius = _attrs.innerRadius,
        outerRadius = _attrs.outerRadius,
        startAngle = _attrs.startAngle,
        endAngle = _attrs.endAngle,
        x = _attrs.x,
        y = _attrs.y,
        rest = _objectWithoutPropertiesLoose(_attrs, ["innerRadius", "outerRadius", "startAngle", "endAngle", "x", "y"]);

    var d = arc$1({
      innerRadius: innerRadius || 0,
      outerRadius: outerRadius || 0,
      startAngle: startAngle || 0,
      endAngle: endAngle || 0
    });
    attrs = _extends({}, attrs, {}, rest, {
      d: d,
      transform: "translate(" + x + ", " + y + ")"
    });
  }

  var node = document.createElementNS(nsString, newTagName);
  Object.keys(attrs).forEach(function (attrName) {
    node.setAttribute(attrName, attrs[attrName]);
  });
  return node;
};

function useDrawEffect(drawFnName, deps, props) {
  if (props === void 0) {
    props = {};
  }

  var value = useContext(Context);
  var nodeRef = useRef(null);
  var fakeNodeRef = useRef(null);

  if (!value) {
    throw Error('Wrap Component inside <RoughProvider>');
  }

  var creteFakeNode = function creteFakeNode() {
    var _value$rough;

    switch (drawFnName) {
      case 'rectangle':
        return createSvgNode('rect', {
          x: deps[0],
          y: deps[1],
          width: deps[2],
          height: deps[3]
        });

      case 'path':
        var pathOptions = deps[1] || {};
        return createSvgNode('path', {
          d: deps[0],
          fill: pathOptions.fill ? 'black' : 'none'
        });

      default:
        var options = deps[deps.length - 1] || {};

        var newOptions = _extends({}, options, {
          fill: 'black',
          fillStyle: 'solid'
        });

        var args = [].concat(deps.slice(0, deps.length - 1), [newOptions]);

        var node = (_value$rough = value.rough)[drawFnName].apply(_value$rough, args);

        node.setAttribute('opacity', '0');
        return node;
    }
  };

  var _props = props,
      transform = _props.transform,
      opacity = _props.opacity,
      onClick = _props.onClick,
      onMouseOut = _props.onMouseOut,
      onMouseOver = _props.onMouseOver,
      cursor = _props.cursor,
      strokeDasharray = _props.strokeDasharray,
      onMouseMove = _props.onMouseMove;
  var handlers = {
    onClick: onClick,
    onMouseOut: onMouseOut,
    onMouseOver: onMouseOver,
    onMouseMove: onMouseMove
  };

  var setAttribute = function setAttribute(node, attrs) {
    Object.keys(attrs).forEach(function (attrName) {
      if (attrName === 'strokeDasharray') {
        node.setAttribute('stroke-dasharray', attrs[attrName]);
        return;
      }

      if (attrs[attrName] !== undefined) {
        node.setAttribute(attrName, attrs[attrName]);
      }
    });
  };

  useEffect(function () {
    if (nodeRef.current) {
      setAttribute(nodeRef.current, {
        transform: transform,
        opacity: opacity,
        cursor: cursor,
        strokeDasharray: strokeDasharray
      });
    }

    if (fakeNodeRef.current) {
      setAttribute(fakeNodeRef.current, {
        transform: transform
      });
    }
  }, [transform, opacity, cursor, strokeDasharray]);
  useShallowEqual(function () {
    if (value.root) {
      var _value$rough2;

      var node = (_value$rough2 = value.rough)[drawFnName].apply(_value$rough2, deps);

      nodeRef.current = node;
      var fakeNode = creteFakeNode();
      fakeNodeRef.current = fakeNode;
      setAttribute(node, {
        transform: transform,
        opacity: opacity,
        cursor: cursor,
        strokeDasharray: strokeDasharray
      });
      value.root.appendChild(node);

      if (fakeNode) {
        loopHandlers(fakeNode, 'addEventListener', handlers);
        setAttribute(fakeNode, {
          transform: transform,
          cursor: cursor
        });
        value.root.appendChild(fakeNode);
      } else {
        loopHandlers(node, 'addEventListener', handlers);
      }

      return function () {
        nodeRef.current = null;
        value.root.removeChild(node);

        if (fakeNode) {
          fakeNodeRef.current = null;
          loopHandlers(fakeNode, 'removeEventListener', handlers);
          value.root.removeChild(fakeNode);
        } else {
          loopHandlers(node, 'removeEventListener', handlers);
        }
      };
    }

    return function () {};
  }, [value.root].concat(deps));
  return value;
}

var Arc = function Arc(props) {
  useDrawEffect('arc', [props.x, props.y, props.width, props.height, props.start, props.stop, props.closed, props.options], props);
  return null;
};
Arc.displayName = 'Arc';
Arc.defaultProps = {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  start: 0,
  stop: Math.PI / 2,
  closed: false
};

var Circle = function Circle(props) {
  useDrawEffect('circle', [props.x, props.y, props.diameter, props.options], props);
  return null;
};
Circle.displayName = 'Circle';
Circle.defaultProps = {
  x: 0,
  y: 0,
  diameter: 0
};

var Curve = function Curve(props) {
  useDrawEffect('curve', [props.points, props.options], props);
  return null;
};
Curve.displayName = 'Curve';
Curve.defaultProps = {
  points: [[0, 0]]
};

var Ellipse = function Ellipse(props) {
  var x = props.x,
      y = props.y,
      width = props.width,
      height = props.height,
      options = props.options;
  useDrawEffect('ellipse', [x, y, width, height, options], props);
  return null;
};
Ellipse.displayName = 'Ellipse';
Ellipse.defaultProps = {
  x: 0,
  y: 0,
  width: 0,
  height: 0
};

var Line = function Line(props) {
  var x1 = props.x1,
      x2 = props.x2,
      y1 = props.y1,
      y2 = props.y2,
      options = props.options;
  useDrawEffect('line', [x1, y1, x2, y2, options], props);
  return null;
};
Line.displayName = 'Line';
Line.defaultProps = {
  x1: 0,
  x2: 0,
  y1: 0,
  y2: 0
};

var LinearPath = function LinearPath(props) {
  useDrawEffect('linearPath', [props.points, props.options], props);
  return null;
};
LinearPath.displayName = 'LinearPath';
LinearPath.defaultProps = {
  points: []
};

var Path = function Path(props) {
  useDrawEffect('path', [props.d, props.options], props);
  return null;
};
Path.displayName = 'Path';
Path.defaultProps = {
  d: ''
};

var Polygon = function Polygon(props) {
  useDrawEffect('polygon', [props.vertices, props.options], props);
  return null;
};
Polygon.displayName = 'Polygon';
Polygon.defaultProps = {
  vertices: []
};

var Rectangle = function Rectangle(props) {
  var x = props.x,
      y = props.y,
      width = props.width,
      height = props.height,
      options = props.options;
  useDrawEffect('rectangle', [x, y, width, height, options], props);
  return null;
};
Rectangle.displayName = 'Rectangle';
Rectangle.defaultProps = {
  x: 0,
  y: 0,
  width: 0,
  height: 0
};

var RoughProvider = function RoughProvider(props) {
  RoughProvider.displayName = 'RoughProvider';
  var Provider = Context.Provider;

  var config = props.config,
      rest = _objectWithoutPropertiesLoose(props, ["config"]);

  var ref = useRef();

  var _React$useState = useState({
    root: null,
    rough: null
  }),
      value = _React$useState[0],
      setValue = _React$useState[1];

  useEffect(function () {
    setValue({
      root: ref.current,
      rough: roughjs.svg(ref.current, props.config)
    });
  }, [ref.current, config]);
  return createElement(Provider, {
    value: value
  }, createElement("g", Object.assign({}, rest, {
    ref: ref
  })));
};

export { Arc, Circle, Context, Curve, Ellipse, Line, LinearPath, Path, Polygon, Rectangle, RoughProvider };
//# sourceMappingURL=index.m.js.map
